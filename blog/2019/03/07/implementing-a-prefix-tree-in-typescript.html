<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=0.5">
  <title>Implementing a prefix tree in typescript</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
<style>
  body {
    margin: auto 0;
  }

  .button {
    border-radius: 2em !important;
  }
  @media (min-width: 768px) {
    .container {
      margin: 0 auto;
      width: 800px;
      font-size: 16px;
      line-height: 130%;
    }  
  }
  
  .header {
    width:100%;
    background-color: black;
    padding: 15px 5px;
    color: white;
  }
  div.sourceCode {
    padding-left: 4px;
    border-left: 2px solid black;
  }
  ul.nav {
    display: inline-flex;
    list-style-type: none;
  }
  ul.nav li {
    margin-left: 12px;  
  }
  ul.nav li a {
    text-decoration: none;
    color: white;
  }
  code {
    font-size: 14px;
    font-weight: 600;
  }
  </style>
</head>
<body>
<div class="header">
  Trshant's Rambling
  <ul class="nav" >
    <li><a href="/archive.html">Archives</a></li>
    <li><a href="/resume.pdf">Resume</a></li>
    <li><a href="/recipes.html">Recipes</a></li>
  </ul>
</div>

<div class="container">
<header>
<h1 class="title">Implementing a prefix tree in typescript</h1>

  <a class="button button-small" href="javascript: void(0)">Algorithm</a>
  <a class="button button-small" href="javascript: void(0)">blog</a>
  <a class="button button-small" href="javascript: void(0)">DataStructures</a>
  <a class="button button-small" href="javascript: void(0)">JavaScript</a>
  <a class="button button-small" href="javascript: void(0)">PrefixTree</a>
  <a class="button button-small" href="javascript: void(0)">Trie</a>
  <a class="button button-small" href="javascript: void(0)">TypeScript</a>


</header>
<p>This post covers the implementation of a prefix tree in typescript. I am avoiding the write up on the datastructure as wikipedia has a real nice <a href="https://en.wikipedia.org/wiki/Trie">one</a> on it. I'll be using the terms &quot;prefix tree&quot; and &quot;trie&quot; interchangeably.</p>
<p>I will start by creating a node. At the least, this node should have (a) the value of the element, (b) a list of child nodes and (c) a way to add to the child node list.</p>
<pre class="typescript"><code>type NumOrStrArray = number[] | string[];

class node {
    value: number|string|null;
    childNodes: NumOrStrArray ;
    constructor(value,parentNode) {
        this.value = value;
        this.childNodes = [];
        if (parentNode != null) {
            parentNode.addChild(this);
        }
    }
    addChild(childNode) {
        this.childNodes.push(childNode);
    }
}</code></pre>
<p>Lets test it with a string:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> mother_node <span class="op">=</span> <span class="kw">new</span> <span class="at">node</span>(<span class="kw">null</span><span class="op">,</span> <span class="kw">null</span>)<span class="op">;</span>
<span class="kw">var</span> string_to_store <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span>
<span class="kw">var</span> previous_node <span class="op">=</span> mother_node<span class="op">;</span>
<span class="kw">var</span> stored_nodes <span class="op">=</span> []<span class="op">;</span>
<span class="va">string_to_store</span>.<span class="at">split</span>(<span class="st">&#39;&#39;</span>).<span class="at">forEach</span>(<span class="kw">function</span> (element<span class="op">,</span> index) <span class="op">{</span>
    <span class="kw">var</span> newNode <span class="op">=</span> <span class="kw">new</span> <span class="at">node</span>(element<span class="op">,</span> previous_node)<span class="op">;</span>
    <span class="va">stored_nodes</span>.<span class="at">push</span>(newNode)<span class="op">;</span>
    previous_node <span class="op">=</span> newNode<span class="op">;</span>
<span class="op">}</span>)
<span class="va">console</span>.<span class="at">log</span>(stored_nodes)<span class="op">;</span>
<span class="at">todo</span>(output)</code></pre></div>
<p>Now lets define a tree as a class, using the node defined above.</p>
<pre class="typescript"><code>class prefix_tree {
    mother_node: any;
    previous_node: any;
    stored_nodes: any[];
    constructor(value) {
        this.mother_node = new node(null, null);
        this.previous_node = this.mother_node;
        this.stored_nodes = [];
    }
    addToTree(StringOrNumber) {
        this.previous_node = this.mother_node;
        for (var element of StringOrNumber.split(&#39;&#39;)) {
            console.log(element, this.previous_node ) ;
            var oldNode = this.previous_node.searchChildNodes(element);
            if (oldNode == null) {
                var newNode = new node(element, this.previous_node);
                this.stored_nodes.push(newNode);
                this.previous_node = newNode;
            } else {
                this.previous_node = oldNode;
            }   
        }
    }
}</code></pre>
<p>As you have probably noticed, the prefix_tree class requires the services of function <code>searchChildNodes</code> in the node class, which is not there in our first definition of node. So we will need to add that.</p>
<pre class="typescript"><code>searchChildNodes(valueToSearch) {
    for (var  element  of  this.childNodes) {
        if ( element.value  ==  valueToSearch) {
            return  element;
        }
    }
    return  null;
}</code></pre>
<p>The complete <code>Node</code> class definition looks like this now:</p>
<pre class="typescript"><code>class node {
    value: number | string | null;
    childNodes: NameOrNameArray;
    constructor(value, parentNode) {
        this.value = value;
        this.childNodes = [];
        if (parentNode != null) {
            parentNode.addChild(this);
        }
    }
    addChild(childNode) {
        this.childNodes.push(childNode);
    }
    searchChildNodes(valueToSearch) {
        for (var element of this.childNodes) {
            if ( element.value == valueToSearch) {
                return element;
            }
            
        }
        return null;
    }
}</code></pre>
<p>Testing it all together:</p>
<pre class="typescript"><code>var  trie  =  new  prefix_tree(null);
trie.addToTree(&quot;to&quot;);
trie.addToTree(&quot;tea&quot;);
console.log(trie.stored_nodes);</code></pre>
<p>You can play around with <a href="https://www.typescriptlang.org/play/#src=type%20NameOrNameArray%20%3D%20number%5B%5D%20%7C%20string%5B%5D%3B%0D%0A%0D%0Aclass%20node%20%7B%0D%0A%20%20%20%20value%3A%20number%20%7C%20string%20%7C%20null%3B%0D%0A%20%20%20%20childNodes%3A%20NameOrNameArray%3B%0D%0A%20%20%20%20constructor(value%2C%20parentNode)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.value%20%3D%20value%3B%0D%0A%20%20%20%20%20%20%20%20this.childNodes%20%3D%20%5B%5D%3B%0D%0A%20%20%20%20%20%20%20%20if%20(parentNode%20!%3D%20null)%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20parentNode.addChild(this)%3B%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%7D%0D%0A%20%20%20%20addChild(childNode)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.childNodes.push(childNode)%3B%0D%0A%20%20%20%20%7D%0D%0A%20%20%20%20searchChildNodes(valueToSearch)%20%7B%0D%0A%20%20%20%20%20%20%20%20for%20(var%20element%20of%20this.childNodes)%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20(element.value%20%3D%3D%20valueToSearch)%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20element%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%20%20%20%20return%20null%3B%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Aclass%20prefix_tree%20%7B%0D%0A%20%20%20%20mother_node%3A%20any%3B%0D%0A%20%20%20%20previous_node%3A%20any%3B%0D%0A%20%20%20%20stored_nodes%3A%20any%5B%5D%3B%0D%0A%20%20%20%20constructor(value)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.mother_node%20%3D%20new%20node(null%2C%20null)%3B%0D%0A%20%20%20%20%20%20%20%20this.previous_node%20%3D%20this.mother_node%3B%0D%0A%20%20%20%20%20%20%20%20this.stored_nodes%20%3D%20%5B%5D%3B%0D%0A%20%20%20%20%20%20%20%20%2F%2Fconsole.log(this.previous_node%2C%20this.mother_node)%3B%0D%0A%20%20%20%20%7D%0D%0A%20%20%20%20addToTree(StringOrNumber)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.previous_node%20%3D%20this.mother_node%3B%0D%0A%20%20%20%20%20%20%20%20for%20(var%20element%20of%20StringOrNumber.split(&#39;&#39;))%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20console.log(element%2C%20this.previous_node%20)%20%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20var%20oldNode%20%3D%20this.previous_node.searchChildNodes(element)%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20(oldNode%20%3D%3D%20null)%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20var%20newNode%20%3D%20new%20node(element%2C%20this.previous_node)%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20this.stored_nodes.push(newNode)%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20this.previous_node%20%3D%20newNode%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20this.previous_node%20%3D%20oldNode%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20%20%20%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Avar%20trie%20%3D%20new%20prefix_tree(null)%3B%0D%0Atrie.addToTree(%22to%22)%3B%0D%0Atrie.addToTree(%22tea%22)%3B%0D%0Aconsole.log(trie.stored_nodes)%3B%0D%0A">this</a> at the <a href="https://www.typescriptlang.org/play/">typescript playground</a>.</p>
<p>However, our work is not done yet. We need to implement a way to search the prefix tree for our data. Here we go:</p>
<pre class="typescript"><code>searchInTree(StringOrNumber) {
    this.previous_node = this.mother_node;
    for (var element of StringOrNumber.split(&#39;&#39;)) {
        var oldNode = this.previous_node.searchChildNodes(element);
        if (oldNode == null) {
            return false;
        }
    }
    var oldNode = this.previous_node.searchChildNodes(null);
    if (oldNode == null) {
        return false;
    }
    return true;
}</code></pre>
<p>Testing this</p>
<pre class="typescript"><code>var trie = new prefix_tree(null);
trie.addToTree(&quot;to&quot;);
trie.addToTree(&quot;tea&quot;);
console.log(trie.stored_nodes);
reply = trie.searchInTree(&quot;toe&quot;);
console.log(reply); // false
reply = trie.searchInTree(&quot;to&quot;);
console.log(reply); // true</code></pre>
<p>And so, we have ourselves a trie. Do check out the code in <a href="https://gist.github.com/Trshant/d16d72d2d5651ca5e39ee0adf95d74ba">github</a>. or you can <a href="https://www.typescriptlang.org/play/#src=type%20NameOrNameArray%20%3D%20number%5B%5D%20%7C%20string%5B%5D%3B%0D%0A%0D%0Aclass%20node%20%7B%0D%0A%20%20%20%20value%3A%20number%20%7C%20string%20%7C%20null%3B%0D%0A%20%20%20%20childNodes%3A%20NameOrNameArray%3B%0D%0A%20%20%20%20constructor(value%2C%20parentNode)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.value%20%3D%20value%3B%0D%0A%20%20%20%20%20%20%20%20this.childNodes%20%3D%20%5B%5D%3B%0D%0A%20%20%20%20%20%20%20%20if%20(parentNode%20!%3D%20null)%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20parentNode.addChild(this)%3B%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%7D%0D%0A%20%20%20%20addChild(childNode)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.childNodes.push(childNode)%3B%0D%0A%20%20%20%20%7D%0D%0A%20%20%20%20searchChildNodes(valueToSearch)%20%7B%0D%0A%20%20%20%20%20%20%20%20var%20element%3A%20any%3B%0D%0A%20%20%20%20%20%20%20%20for%20(%20element%20of%20this.childNodes)%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20(element.value%20%3D%3D%20valueToSearch)%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20element%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%20%20%20%20return%20null%3B%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Aclass%20prefix_tree%20%7B%0D%0A%20%20%20%20mother_node%3A%20any%3B%0D%0A%20%20%20%20previous_node%3A%20any%3B%0D%0A%20%20%20%20stored_nodes%3A%20any%5B%5D%3B%0D%0A%20%20%20%20constructor(value)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.mother_node%20%3D%20new%20node(null%2C%20null)%3B%0D%0A%20%20%20%20%20%20%20%20this.previous_node%20%3D%20this.mother_node%3B%0D%0A%20%20%20%20%20%20%20%20this.stored_nodes%20%3D%20%5B%5D%3B%0D%0A%20%20%20%20%20%20%20%20%2F%2Fconsole.log(this.previous_node%2C%20this.mother_node)%3B%0D%0A%20%20%20%20%7D%0D%0A%20%20%20%20addToTree(StringOrNumber)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.previous_node%20%3D%20this.mother_node%3B%0D%0A%20%20%20%20%20%20%20%20for%20(var%20element%20of%20StringOrNumber.split(&#39;&#39;))%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2Fconsole.log(element%2C%20this.previous_node%20)%20%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20var%20oldNode%20%3D%20this.previous_node.searchChildNodes(element)%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20(oldNode%20%3D%3D%20null)%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20var%20newNode%20%3D%20new%20node(element%2C%20this.previous_node)%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20this.stored_nodes.push(newNode)%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20this.previous_node%20%3D%20newNode%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20this.previous_node%20%3D%20oldNode%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20%20%20%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%20%20%20%20var%20newNode%20%3D%20new%20node(null%2C%20this.previous_node)%3B%0D%0A%20%20%20%20%20%20%20%20this.stored_nodes.push(newNode)%3B%0D%0A%20%20%20%20%7D%0D%0A%20%20%20%20searchInTree(StringOrNumber)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.previous_node%20%3D%20this.mother_node%3B%0D%0A%20%20%20%20%20%20%20%20for%20(var%20element%20of%20StringOrNumber.split(&#39;&#39;))%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20var%20oldNode%20%3D%20this.previous_node.searchChildNodes(element)%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20(oldNode%20%3D%3D%20null)%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20false%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20this.previous_node%20%3D%20oldNode%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%20%20%20%20var%20oldNode%20%3D%20this.previous_node.searchChildNodes(null)%3B%0D%0A%20%20%20%20%20%20%20%20if%20(oldNode%20%3D%3D%20null)%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20false%3B%0D%0A%20%20%20%20%20%20%20%20%7D%20%0D%0A%20%20%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Avar%20trie%20%3D%20new%20prefix_tree(null)%3B%0D%0Atrie.addToTree(%22to%22)%3B%0D%0Atrie.addToTree(%22tea%22)%3B%0D%0Aconsole.log(trie.stored_nodes)%3B%0D%0Areply%20%3D%20trie.searchInTree(%22toe%22)%3B%0D%0Aconsole.log(reply)%3B%0D%0Areply%20%3D%20trie.searchInTree(%22to%22)%3B%0D%0Aconsole.log(reply)%3B">play</a> with it &gt; Written with <a href="https://stackedit.io/">StackEdit</a>. <!--stackedit_data:
eyJoaXN0b3J5IjpbNTA1Mjc0MjUxLC0yNjI2NzU2MV19
--></p>
<link rel="stylesheet" href="https://cdn.rawgit.com/knsv/mermaid/6.0.0/dist/mermaid.css">
<script src="https://cdn.rawgit.com/knsv/mermaid/6.0.0/dist/mermaid.min.js"></script>
<script>mermaid.initialize({startOnLoad:true});</script>
</div>
</body>
</html>
